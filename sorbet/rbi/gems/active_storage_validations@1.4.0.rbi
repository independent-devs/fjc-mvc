# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_storage_validations` gem.
# Please instead update this file by running `bin/tapioca gem active_storage_validations`.


# source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#3
module ActiveStorageValidations; end

# ActiveStorageValidations::ASVActiveStorageable
#
# Validator helper methods to make our code more explicit.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#7
module ActiveStorageValidations::ASVActiveStorageable
  extend ::ActiveSupport::Concern

  private

  # Retrieve either an `ActiveStorage::Attached::One` or an
  # `ActiveStorage::Attached::Many` instance depending on attribute definition
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#14
  def attached_files(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#18
  def attachments_present?(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#22
  def no_attachments?(record, attribute); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_active_storageable.rb#26
  def will_have_attachments_after_save?(record, attribute); end
end

# ActiveStorageValidations::ASVAnalyzable
#
# Validator methods for choosing the right analyzer depending on the file
# media type and available third-party analyzers.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#8
module ActiveStorageValidations::ASVAnalyzable
  extend ::ActiveSupport::Concern

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#19
  def analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#41
  def fallback_analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#26
  def image_analyzer_for(attachable); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#35
  def image_processor; end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#15
  def metadata_for(attachable); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_analyzable.rb#11
ActiveStorageValidations::ASVAnalyzable::DEFAULT_IMAGE_PROCESSOR = T.let(T.unsafe(nil), Symbol)

# ActiveStorageValidations::ASVAttachable
#
# Validator methods for analyzing attachable.
#
# An attachable is a file representation such as ActiveStorage::Blob,
# ActionDispatch::Http::UploadedFile, Rack::Test::UploadedFile, Hash, String,
# File or Pathname
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#11
module ActiveStorageValidations::ASVAttachable
  extend ::ActiveSupport::Concern

  private

  # Retrieve the declared content_type from attachable without potential mime
  # type parameters (e.g. 'application/x-rar-compressed;version=5')
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#62
  def attachable_content_type(attachable); end

  # Retrieve the content_type from attachable using the same logic as Rails
  # ActiveStorage::Blob::Identifiable#identify_content_type
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#68
  def attachable_content_type_rails_like(attachable); end

  # Retrieve the declared filename from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#132
  def attachable_filename(attachable); end

  # Retrieve the io from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#84
  def attachable_io(attachable, max_byte_size: T.unsafe(nil)); end

  # Retrieve the media type of the attachable, which is the first part of the
  # content type (or mime type).
  # Possible values are: application/audio/example/font/image/model/text/video
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#79
  def attachable_media_type(attachable); end

  # Retrieve an array of newly submitted attachables. Some file could be passed
  # several times, we just need to perform the analysis once on the file,
  # therefore the use of #uniq.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#28
  def attachables_from_changes(record, attribute); end

  # Retrieve the full declared content_type from attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#38
  def full_attachable_content_type(attachable); end

  # Retrieve the content_type from the file name only
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#179
  def marcel_content_type_from_filename(attachable); end

  # Raise the same Rails error for not-implemented file representations.
  #
  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#155
  def raise_rails_like_error(attachable); end

  # Rewind the io attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#112
  def rewind_attachable_io(attachable); end

  # Check if the current Rails version supports ActiveStorage::Blob#download_chunk
  #
  # https://github.com/rails/rails/blob/7-0-stable/activestorage/CHANGELOG.md#rails-700alpha1-september-15-2021
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#174
  def supports_blob_download_chunk?; end

  # Check if the current Rails version supports File or Pathname attachment
  #
  # https://github.com/rails/rails/blob/7-1-stable/activestorage/CHANGELOG.md#rails-710rc1-september-27-2023
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#166
  def supports_file_attachment?; end

  # Check if the current Rails version supports File or Pathname attachment
  #
  # https://github.com/rails/rails/blob/7-1-stable/activestorage/CHANGELOG.md#rails-710rc1-september-27-2023
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#166
  def supports_pathname_attachment?; end

  # Loop through the newly submitted attachables to validate them. Using
  # attachables is the only way to get the attached file io that is necessary
  # to perform file analyses.
  #
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_attachable.rb#19
  def validate_changed_files_from_metadata(record, attribute); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#4
module ActiveStorageValidations::ASVErrorable
  extend ::ActiveSupport::Concern

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#20
  def add_error(record, attribute, error_type, **errors_options); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#7
  def initialize_error_options(options, file = T.unsafe(nil)); end

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_errorable.rb#30
  def get_filename(file); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_loggable.rb#4
module ActiveStorageValidations::ASVLoggable
  extend ::ActiveSupport::Concern

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_loggable.rb#7
  def logger; end
end

# ActiveStorageValidations::ASVOptionable
#
# Helper method to flatten the validator options.
#
# source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#7
module ActiveStorageValidations::ASVOptionable
  extend ::ActiveSupport::Concern

  private

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#16
  def flatten_options(record, options, available_checks = T.unsafe(nil)); end

  # source://active_storage_validations//lib/active_storage_validations/shared/asv_optionable.rb#12
  def set_flat_options(record); end
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#4
module ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveStorageValidations::ASVSymbolizable::ClassMethods
end

# source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#0
module ActiveStorageValidations::ASVSymbolizable::ClassMethods
  # source://active_storage_validations//lib/active_storage_validations/shared/asv_symbolizable.rb#8
  def to_sym; end
end

# = Active Storage Validations \Analyzer
#
# This is an abstract base class for analyzers, which extract metadata from attachables.
# See ActiveStorageValidations::Analyzer::ImageAnalyzer for an example of a concrete subclass.
#
# Heavily (not to say 100%) inspired by Rails own ActiveStorage::Analyzer
#
# source://active_storage_validations//lib/active_storage_validations/analyzer.rb#13
class ActiveStorageValidations::Analyzer
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVLoggable

  # @return [Analyzer] a new instance of Analyzer
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#19
  def initialize(attachable); end

  # Returns the value of attribute attachable.
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#17
  def attachable; end

  # Override this method in a concrete subclass. Have it return a Hash of metadata.
  #
  # @raise [NotImplementedError]
  #
  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#24
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer.rb#30
  def instrument(analyzer, &block); end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#14
class ActiveStorageValidations::Analyzer::ImageAnalyzer < ::ActiveStorageValidations::Analyzer
  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#17
  def metadata; end

  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#69
  def analyzer_supported?; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#31
  def image(tempfile); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#81
  def image_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#56
  def image_from_tempfile_path(tempfile, file_representation); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#77
  def read_image; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#85
  def rotated_image?(image); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer.rb#89
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#7
class ActiveStorageValidations::Analyzer::ImageAnalyzer::ImageMagick < ::ActiveStorageValidations::Analyzer::ImageAnalyzer
  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#29
  def image_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#11
  def read_image; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#35
  def rotated_image?(image); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/image_magick.rb#39
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#6
class ActiveStorageValidations::Analyzer::ImageAnalyzer::Vips < ::ActiveStorageValidations::Analyzer::ImageAnalyzer
  private

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#28
  def image_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#10
  def read_image; end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#52
  def rotated_image?(image); end

  # source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#43
  def supported?; end
end

# source://active_storage_validations//lib/active_storage_validations/analyzer/image_analyzer/vips.rb#51
ActiveStorageValidations::Analyzer::ImageAnalyzer::Vips::ROTATIONS = T.let(T.unsafe(nil), Regexp)

# source://active_storage_validations//lib/active_storage_validations/analyzer/null_analyzer.rb#13
class ActiveStorageValidations::Analyzer::NullAnalyzer < ::ActiveStorageValidations::Analyzer
  # source://active_storage_validations//lib/active_storage_validations/analyzer/null_analyzer.rb#14
  def metadata; end
end

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#11
class ActiveStorageValidations::AspectRatioValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#32
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#37
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#72
  def aspect_ratio_error_mapping; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#54
  def authorized_aspect_ratio?(record, attribute, attachable, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#132
  def authorized_aspect_ratios_from_options(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#114
  def ensure_aspect_ratio_validity; end

  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#108
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#79
  def image_metadata_missing?(record, attribute, attachable, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#124
  def invalid_aspect_ratio_message; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#49
  def is_valid?(record, attribute, attachable, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#136
  def string_aspect_ratios; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#96
  def valid_landscape_aspect_ratio?(metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#92
  def valid_portrait_aspect_ratio?(metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#100
  def valid_regex_aspect_ratio?(aspect_ratio, metadata); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#88
  def valid_square_aspect_ratio?(metadata); end
end

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#21
ActiveStorageValidations::AspectRatioValidator::ASPECT_RATIO_REGEX = T.let(T.unsafe(nil), Regexp)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#19
ActiveStorageValidations::AspectRatioValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#22
ActiveStorageValidations::AspectRatioValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#20
ActiveStorageValidations::AspectRatioValidator::NAMED_ASPECT_RATIOS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#30
ActiveStorageValidations::AspectRatioValidator::PRECISION = T.let(T.unsafe(nil), Integer)

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#8
class ActiveStorageValidations::AttachedValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#15
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#23
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#13
ActiveStorageValidations::AttachedValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#9
class ActiveStorageValidations::BaseSizeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # @return [BaseSizeValidator] a new instance of BaseSizeValidator
  #
  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#25
  def initialize(*args); end

  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#32
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#15
  def number_to_human_size(*_arg0, **_arg1, &_arg2); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#40
  def is_valid?(size, flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#65
  def max_size(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#61
  def min_size(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#56
  def populate_error_options(errors_options, flat_options); end
end

# source://active_storage_validations//lib/active_storage_validations/base_size_validator.rb#17
ActiveStorageValidations::BaseSizeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#9
class ActiveStorageValidations::ContentTypeSpoofDetector
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVLoggable

  # @return [ContentTypeSpoofDetector] a new instance of ContentTypeSpoofDetector
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#16
  def initialize(record, attribute, attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#22
  def spoofed?; end

  private

  # Return the content_type found by Open3 analysis.
  #
  # Using Open3 is a better alternative than Marcel (Marcel::MimeType.for(io))
  # for analyzing content type solely based on the file io.
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#49
  def content_type_from_analyzer; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#88
  def enlarged_content_type(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#33
  def filename; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#41
  def io; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#53
  def open3_mime_type_for_io; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#92
  def parent_content_types(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#37
  def supplied_content_type; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#81
  def supplied_content_type_intersects_content_type_from_analyzer?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#76
  def supplied_content_type_vs_open3_analizer_mismatch?; end
end

# source://active_storage_validations//lib/active_storage_validations/content_type_spoof_detector.rb#10
class ActiveStorageValidations::ContentTypeSpoofDetector::FileCommandLineToolNotInstalledError < ::StandardError; end

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#12
class ActiveStorageValidations::ContentTypeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#26
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#31
  def validate_each(record, attribute, _value); end

  private

  # errors_options = initialize_and_populate_error_options(options, attachable)
  #   add_error(record, attribute, ERROR_TYPES.first, **errors_options)
  #   false
  # end
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#90
  def authorized_content_type?(record, attribute, attachable); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#47
  def authorized_content_types_from_options(record); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#137
  def content_type_to_human_format(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#121
  def disable_spoofing_protection?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#125
  def enable_spoofing_protection?; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#158
  def ensure_content_types_validity; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#152
  def ensure_exactly_one_validator_option; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#129
  def initialize_and_populate_error_options(options, attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#189
  def invalid_content_type?(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#166
  def invalid_content_type_option_message(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#193
  def invalid_extension?(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#180
  def invalid_option?(content_type); end

  # Check if the provided content_type is authorized and not spoofed against
  # the file io.
  #
  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#65
  def is_valid?(record, attribute, attachable); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#117
  def marcel_attachable_content_type(attachable); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#105
  def not_spoofing_content_type?(record, attribute, attachable); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#58
  def set_attachable_cached_values(attachable); end
end

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#20
ActiveStorageValidations::ContentTypeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#21
ActiveStorageValidations::ContentTypeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#11
class ActiveStorageValidations::DimensionValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#34
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#40
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#48
  def is_valid?(record, attribute, file, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#127
  def process_options(record); end
end

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#19
ActiveStorageValidations::DimensionValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#20
ActiveStorageValidations::DimensionValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/engine.rb#4
class ActiveStorageValidations::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.2.2.1/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#9
class ActiveStorageValidations::LimitValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVOptionable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#20
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#25
  def validate_each(record, attribute, _value); end

  private

  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#55
  def ensure_arguments_validity; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#49
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#39
  def files_count_valid?(count, flat_options); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#76
  def min_higher_than_max?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#62
  def min_max_are_proc?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#71
  def min_or_max_defined_and_not_integer?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#66
  def min_or_max_is_proc_and_other_not_present?; end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#15
ActiveStorageValidations::LimitValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#16
ActiveStorageValidations::LimitValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#10
class ActiveStorageValidations::ProcessableImageValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::ASVActiveStorageable
  include ::ActiveStorageValidations::ASVAnalyzable
  include ::ActiveStorageValidations::ASVAttachable
  include ::ActiveStorageValidations::ASVErrorable
  include ::ActiveStorageValidations::ASVSymbolizable
  extend ::ActiveStorageValidations::ASVSymbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#21
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#29
  def is_valid?(record, attribute, attachable, metadata); end
end

# source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#17
ActiveStorageValidations::ProcessableImageValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/railtie.rb#4
class ActiveStorageValidations::Railtie < ::Rails::Railtie; end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#6
class ActiveStorageValidations::SizeValidator < ::ActiveStorageValidations::BaseSizeValidator
  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#15
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#7
ActiveStorageValidations::SizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#6
class ActiveStorageValidations::TotalSizeValidator < ::ActiveStorageValidations::BaseSizeValidator
  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#15
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#37
  def custom_check_validity!(record, attribute); end
end

# source://active_storage_validations//lib/active_storage_validations/total_size_validator.rb#7
ActiveStorageValidations::TotalSizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)
