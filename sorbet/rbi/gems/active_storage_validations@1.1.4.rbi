# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `active_storage_validations` gem.
# Please instead update this file by running `bin/tapioca gem active_storage_validations`.


# source://active_storage_validations//lib/active_storage_validations/railtie.rb#3
module ActiveStorageValidations; end

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#8
class ActiveStorageValidations::AspectRatioValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#26
  def check_validity!; end

  # Rails 5
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#32
  def validate_each(record, attribute, _value); end

  private

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#115
  def ensure_aspect_ratio_validity; end

  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#109
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#66
  def is_valid?(record, attribute, file, metadata); end
end

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#15
ActiveStorageValidations::AspectRatioValidator::ASPECT_RATIO_REGEX = T.let(T.unsafe(nil), Regexp)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#13
ActiveStorageValidations::AspectRatioValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#16
ActiveStorageValidations::AspectRatioValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#14
ActiveStorageValidations::AspectRatioValidator::NAMED_ASPECT_RATIOS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/aspect_ratio_validator.rb#24
ActiveStorageValidations::AspectRatioValidator::PRECISION = T.let(T.unsafe(nil), Integer)

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#7
class ActiveStorageValidations::AttachedValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#13
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#21
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/attached_validator.rb#11
ActiveStorageValidations::AttachedValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#7
class ActiveStorageValidations::ContentTypeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#39
  def authorized_types(record); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#15
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#56
  def content_type(file); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#73
  def ensure_content_types_validity; end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#67
  def ensure_exactly_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#88
  def invalid_content_type?(content_type); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#81
  def invalid_content_type_message(content_type); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#60
  def is_valid?(file, types); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#50
  def types_to_human_format(types); end

  # source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#20
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#12
ActiveStorageValidations::ContentTypeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/content_type_validator.rb#13
ActiveStorageValidations::ContentTypeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#8
class ActiveStorageValidations::DimensionValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#50
  def check_validity!; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#88
  def is_valid?(record, attribute, file, metadata); end

  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#28
  def process_options(record); end

  # Rails 5
  #
  # source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#58
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#13
ActiveStorageValidations::DimensionValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/dimension_validator.rb#14
ActiveStorageValidations::DimensionValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/engine.rb#4
class ActiveStorageValidations::Engine < ::Rails::Engine
  class << self
    # source://activesupport/7.1.3.4/lib/active_support/callbacks.rb#70
    def __callbacks; end
  end
end

# source://active_storage_validations//lib/active_storage_validations/concerns/errorable.rb#2
module ActiveStorageValidations::Errorable
  extend ::ActiveSupport::Concern

  # source://active_storage_validations//lib/active_storage_validations/concerns/errorable.rb#18
  def add_error(record, attribute, error_type, **errors_options); end

  # source://active_storage_validations//lib/active_storage_validations/concerns/errorable.rb#5
  def initialize_error_options(options, file = T.unsafe(nil)); end

  private

  # source://active_storage_validations//lib/active_storage_validations/concerns/errorable.rb#29
  def get_filename(file); end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#7
class ActiveStorageValidations::LimitValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#17
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#22
  def validate_each(record, attribute, _); end

  private

  # @raise [ArgumentError]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#52
  def ensure_arguments_validity; end

  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#46
  def ensure_at_least_one_validator_option; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#36
  def files_count_valid?(count, flat_options); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#73
  def min_higher_than_max?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#59
  def min_max_are_proc?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#68
  def min_or_max_defined_and_not_integer?; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#63
  def min_or_max_is_proc_and_other_not_present?; end
end

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#12
ActiveStorageValidations::LimitValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/limit_validator.rb#13
ActiveStorageValidations::LimitValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/metadata.rb#2
class ActiveStorageValidations::Metadata
  # @return [Metadata] a new instance of Metadata
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#9
  def initialize(file); end

  # Returns the value of attribute file.
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#5
  def file; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#21
  def metadata; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#14
  def valid?; end

  private

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#49
  def exception_class; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#36
  def image_processor; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#160
  def logger; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#103
  def new_image_from_path(path); end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#138
  def read_file_path; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#60
  def read_image; end

  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#42
  def require_image_processor; end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#127
  def rotated_image?(image); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#119
  def valid_image?(image); end

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/metadata.rb#56
  def vips_image_processor?; end
end

# source://active_storage_validations//lib/active_storage_validations/metadata.rb#7
ActiveStorageValidations::Metadata::DEFAULT_IMAGE_PROCESSOR = T.let(T.unsafe(nil), Symbol)

# source://active_storage_validations//lib/active_storage_validations/metadata.rb#3
class ActiveStorageValidations::Metadata::InvalidImageError < ::StandardError; end

# source://active_storage_validations//lib/active_storage_validations/option_proc_unfolding.rb#2
module ActiveStorageValidations::OptionProcUnfolding
  # source://active_storage_validations//lib/active_storage_validations/option_proc_unfolding.rb#4
  def unfold_procs(record, object, only_keys); end
end

# :nodoc
#
# source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#8
class ActiveStorageValidations::ProcessableImageValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # Rails 5
  #
  # source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#18
  def validate_each(record, attribute, _value); end
end

# source://active_storage_validations//lib/active_storage_validations/processable_image_validator.rb#13
ActiveStorageValidations::ProcessableImageValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/railtie.rb#4
class ActiveStorageValidations::Railtie < ::Rails::Railtie; end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#7
class ActiveStorageValidations::SizeValidator < ::ActiveModel::EachValidator
  include ::ActiveStorageValidations::OptionProcUnfolding
  include ::ActiveStorageValidations::Errorable
  include ::ActiveStorageValidations::Symbolizable
  extend ::ActiveStorageValidations::Symbolizable::ClassMethods

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#29
  def check_validity!; end

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#12
  def number_to_human_size(*_arg0, **_arg1, &_arg2); end

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#35
  def validate_each(record, attribute, _value); end

  private

  # @return [Boolean]
  #
  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#59
  def is_valid?(file_size, flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#79
  def max_size(flat_options); end

  # source://active_storage_validations//lib/active_storage_validations/size_validator.rb#75
  def min_size(flat_options); end
end

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#14
ActiveStorageValidations::SizeValidator::AVAILABLE_CHECKS = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/size_validator.rb#21
ActiveStorageValidations::SizeValidator::ERROR_TYPES = T.let(T.unsafe(nil), Array)

# source://active_storage_validations//lib/active_storage_validations/concerns/symbolizable.rb#2
module ActiveStorageValidations::Symbolizable
  extend ::ActiveSupport::Concern

  mixes_in_class_methods ::ActiveStorageValidations::Symbolizable::ClassMethods
end

# source://active_storage_validations//lib/active_storage_validations/concerns/symbolizable.rb#0
module ActiveStorageValidations::Symbolizable::ClassMethods
  # source://active_storage_validations//lib/active_storage_validations/concerns/symbolizable.rb#6
  def to_sym; end
end
